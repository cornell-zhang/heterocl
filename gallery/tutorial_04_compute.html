
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Compute Customization &#8212; HeteroCL Documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic_mod.css?v=0.7.0-1" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/js/theme.js"></script>
    <script src="../_static/js/petite-vue.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Data Type Customization" href="tutorial_05_dtype.html" />
    <link rel="prev" title="HeteroCL Compute APIs" href="tutorial_03_api.html" /> 
  </head><body data-dark_mode_code_blocks="true">

<div id="top_nav">
    

    <nav>
        
            
        

        <p id="toggle_sidebar">
            <a href="#" title="Toggle sidebar">|||</a>
        </p>
        <h1><a href="../index.html" title="Go to homepage">HeteroCL Documentation</a></h1>
            <a id="source_link" href="https://github.com/cornell-zhang/heterocl">
    
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512">
            <path fill="white" d="M 244.8,8 C 106.1,8 0,113.3 0,252 c 0,110.9 69.8,205.8 169.5,239.2 12.8,2.3 17.3,-5.6 17.3,-12.1 0,-6.2 -0.3,-40.4 -0.3,-61.4 0,0 -70,15 -84.7,-29.8 0,0 -11.4,-29.1 -27.8,-36.6 0,0 -22.9,-15.7 1.6,-15.4 0,0 24.9,2 38.6,25.8 21.9,38.6 58.6,27.5 72.9,20.9 2.3,-16 8.8,-27.1 16,-33.7 -55.9,-6.2 -112.3,-14.3 -112.3,-110.5 0,-27.5 7.6,-41.3 23.6,-58.9 -2.6,-6.5 -11.1,-33.3 2.6,-67.9 20.9,-6.5 69,27 69,27 20,-5.6 41.5,-8.5 62.8,-8.5 21.3,0 42.8,2.9 62.8,8.5 0,0 48.1,-33.6 69,-27 13.7,34.7 5.2,61.4 2.6,67.9 16,17.7 25.8,31.5 25.8,58.9 0,96.5 -58.9,104.2 -114.8,110.5 9.2,7.9 17,22.9 17,46.4 0,33.7 -0.3,75.4 -0.3,83.6 0,6.5 4.6,14.4 17.3,12.1 C 428.2,457.8 496,362.9 496,252 496,113.3 383.5,8 244.8,8 Z"/>
        </svg>
    
</a>
        

        <a id="mode_toggle" href="#" @click.prevent="handleClick" :title="mode">
    <template v-if="mode == 'light'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_light"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M67.48,18.073c1.913,-1.912 1.913,-5.018 0,-6.931c-1.912,-1.912 -5.018,-1.912 -6.931,0l-6.798,6.799c-1.912,1.912 -1.912,5.018 0,6.931c1.913,1.912 5.018,1.912 6.931,-0l6.798,-6.799Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.728,61.108c1.912,-1.913 1.912,-5.018 -0,-6.931c-1.913,-1.913 -5.019,-1.913 -6.931,-0l-6.799,6.798c-1.912,1.913 -1.912,5.019 0,6.931c1.913,1.913 5.019,1.913 6.931,0l6.799,-6.798Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.682,54.177c-1.913,-1.913 -5.018,-1.913 -6.931,-0c-1.912,1.913 -1.912,5.018 0,6.931l6.798,6.798c1.913,1.913 5.019,1.913 6.931,0c1.913,-1.912 1.913,-5.018 0,-6.931l-6.798,-6.798Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M4.901,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,-0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M18.929,11.142c-1.912,-1.912 -5.018,-1.912 -6.931,0c-1.912,1.913 -1.912,5.019 0,6.931l6.799,6.799c1.912,1.912 5.018,1.912 6.931,-0c1.912,-1.913 1.912,-5.019 -0,-6.931l-6.799,-6.799Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.108,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c-0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c-0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'dark'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_dark"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.901,2.196 -4.901,4.901c0,2.705 2.197,4.901 4.901,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.662,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.989,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.732,61.103c1.91,-1.91 1.91,-5.011 0,-6.921l-0.009,-0.01c-1.91,-1.91 -5.012,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.909,1.91 5.011,1.91 6.92,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.672,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.52,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l-0,-0.01c-0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.901,2.196 -4.901,4.901c0,2.704 2.197,4.9 4.901,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.73,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 -0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.098,34.623c-2.699,0 -4.891,2.192 -4.891,4.892l-0,0.019c-0,2.699 2.192,4.891 4.891,4.891c2.7,0 4.892,-2.192 4.892,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.892,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'darkest'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_darkest"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><path d="M39.315,23.791c8.684,-0 15.734,7.05 15.734,15.733c0,8.684 -7.05,15.734 -15.734,15.734c-8.683,0 -15.733,-7.05 -15.733,-15.734c-0,-8.683 7.05,-15.733 15.733,-15.733Zm0,4.737c6.069,0 10.997,4.927 10.997,10.996c-0,6.069 -4.928,10.996 -10.997,10.996c-6.068,0 -10.996,-4.927 -10.996,-10.996c0,-6.069 4.928,-10.996 10.996,-10.996Z" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.216,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.9,2.196 -4.9,4.901c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.666,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.99,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.737,61.103c1.909,-1.91 1.909,-5.011 -0,-6.921l-0.01,-0.01c-1.91,-1.91 -5.011,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.91,1.91 5.011,1.91 6.921,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.676,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.524,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l0,-0.01c0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.216,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901c-0,2.704 2.196,4.9 4.9,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.734,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.103,34.623c-2.7,0 -4.892,2.192 -4.892,4.892l-0,0.019c-0,2.699 2.192,4.891 4.892,4.891c2.699,0 4.891,-2.192 4.891,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.891,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>
</a>

<script>
(function() {
    const LOCAL_STORAGE_KEY = 'piccoloThemeMode'

    var initialMode = localStorage.getItem(LOCAL_STORAGE_KEY)

    if (initialMode) {
        // Make sure the value in local storage is valid
        if (['light', 'dark', 'darkest'].indexOf(initialMode) == -1) {
            initialMode = 'light'
            localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
        }
    } else {
        // Check if the client prefers dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            initialMode = 'dark'
        } else {
            initialMode = 'light'
        }
        localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
    }

    document.documentElement.dataset.mode = initialMode

    PetiteVue.createApp({
        'mode': initialMode,
        handleClick() {
            let currentMode = this.mode

            if (currentMode == 'light') {
                this.mode = 'dark'
            } else if (currentMode == 'dark') {
                this.mode = 'darkest'
            } else if (currentMode == 'darkest') {
                this.mode = 'light'
            }

            document.documentElement.dataset.mode = this.mode
            localStorage.setItem(LOCAL_STORAGE_KEY, this.mode)

            console.log(this.mode)
        }
    }).mount('#mode_toggle')
})()
</script>
            <p class="mobile_search_link">
                <a href="../search.html" title="Search">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 65 64" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2">
                        <path d="M14.873 40.009c-2.315-3.943-3.642-8.532-3.642-13.429C11.231 11.91 23.141 0 37.811 0s26.58 11.91 26.58 26.58-11.91 26.58-26.58 26.58a26.44 26.44 0 0 1-14.277-4.161L9.739 62.794a3.12 3.12 0 0 1-4.413 0L.913 58.382c-1.217-1.218-1.217-3.196 0-4.413l13.96-13.96zM37.811 8.054c10.225 0 18.526 8.301 18.526 18.526s-8.301 18.526-18.526 18.526-18.526-8.301-18.526-18.526S27.586 8.054 37.811 8.054z" fill="#fff" />
                    </svg>
                </a>
            </p>
        

        <div class="searchbox_wrapper">
            
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
    </nav>
</div>

    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup/index.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial_01_get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_02_imperative.html">Imperative Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_03_api.html">HeteroCL Compute APIs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Compute Customization</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_05_dtype.html">Data Type Customization</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_06_memory.html">Memory Customization</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_07_module.html">Custom Module Definition</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_08_backend.html">Back-end Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_09_stencil.html">Use the Stencil Backend</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

        </div>
      </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-gallery-tutorial-04-compute-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<section class="sphx-glr-example-title" id="compute-customization">
<span id="sphx-glr-gallery-tutorial-04-compute-py"></span><h1>Compute Customization<a class="headerlink" href="#compute-customization" title="Permalink to this headline"><span>¶</span></a></h1>
<p><strong>Author</strong>: Yi-Hsiang Lai (<a class="reference external" href="mailto:seanlatias&#37;&#52;&#48;github">seanlatias<span>&#64;</span>github</a>)</p>
<p>In this tutorial, we will demonstrate how to apply hardware customization to a
HeteroCL application. More specifically, we will focus on compute
customization, including loop transformation and parallelism. We will
introduce several compute customization primitives.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heterocl</span> <span class="k">as</span> <span class="nn">hcl</span>
</pre></div>
</div>
<section id="hardware-customization">
<h2>Hardware Customization<a class="headerlink" href="#hardware-customization" title="Permalink to this headline"><span>¶</span></a></h2>
<p>Hardware customization is important in hardware applications. HeteroCL
provides a clean abstraction that can capture different types of hardware
customization. Typical hardware customization includes compute customization,
data type customization, and memory customization. In this tutorial, we will
focus on compute customization. We can categorize compute customization into
two types: loop transformation and parallelism. We will introduce them
respectively. This is also where <code class="docutils literal notranslate"><span class="pre">hcl.create_schedule</span></code> comes in. We will
use a single two-stage computation to demonstrate some of the customization
primitives.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hcl</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="s2">&quot;A&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">two_stage</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">B</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>


<span class="n">s</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">([</span><span class="n">A</span><span class="p">],</span> <span class="n">two_stage</span><span class="p">)</span>
<span class="n">s_B</span> <span class="o">=</span> <span class="n">two_stage</span><span class="o">.</span><span class="n">B</span>
</pre></div>
</div>
<p>Note that we can get the stage by accessing the properties of the function
that defines the algorithm <cite>two_stage</cite>. To access the stage in this way, you
<strong>need to name the stages</strong>.</p>
<p>This is the generated IR without applying any hardware customization.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">hcl</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>module {
  func.func @top(%arg0: memref&lt;10x100xi32&gt;) -&gt; memref&lt;10x100xi32&gt; attributes {itypes = &quot;s&quot;, otypes = &quot;s&quot;} {
    %0 = memref.alloc() {name = &quot;B&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 10 {
      affine.for %arg2 = 0 to 100 {
        %2 = affine.load %arg0[%arg1, %arg2] {from = &quot;A&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %3 = arith.extsi %2 : i32 to i33
        %4 = arith.extsi %c1_i32 : i32 to i33
        %5 = arith.addi %3, %4 : i33
        %6 = arith.trunci %5 : i33 to i32
        affine.store %6, %0[%arg1, %arg2] {to = &quot;B&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y&quot;}
    } {loop_name = &quot;x&quot;, op_name = &quot;B&quot;}
    %1 = memref.alloc() {name = &quot;C&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 10 {
      affine.for %arg2 = 0 to 100 {
        %2 = affine.load %0[%arg1, %arg2] {from = &quot;B&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %3 = arith.extsi %2 : i32 to i33
        %4 = arith.extsi %c1_i32 : i32 to i33
        %5 = arith.addi %3, %4 : i33
        %6 = arith.trunci %5 : i33 to i32
        affine.store %6, %1[%arg1, %arg2] {to = &quot;C&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y_0&quot;}
    } {loop_name = &quot;x_0&quot;, op_name = &quot;C&quot;}
    return %1 : memref&lt;10x100xi32&gt;
  }
}
</pre></div>
</div>
<p>We can take a look at the dataflow graph to visualize the relation between
stages.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">dataflow_graph</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
</section>
<section id="loop-transformation">
<h2>Loop Transformation<a class="headerlink" href="#loop-transformation" title="Permalink to this headline"><span>¶</span></a></h2>
<p>Applying loop transformations to our application can potentially increase
the parallelism inside our program. HeteroCL provides several loop
transformation primitives.</p>
<section id="reorder">
<h3><code class="docutils literal notranslate"><span class="pre">reorder</span></code><a class="headerlink" href="#reorder" title="Permalink to this headline"><span>¶</span></a></h3>
<p>The first primitive we introduce here is loop reordering. With this primitive,
we can redefine the order of a loop nest. For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">([</span><span class="n">A</span><span class="p">],</span> <span class="n">two_stage</span><span class="p">)</span>
<span class="n">s</span><span class="p">[</span><span class="n">s_B</span><span class="p">]</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">s_B</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s_B</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>To apply a compute customization primitive, we need to use the schedule
we created. We can also access the axis of a stage by its index. In this
example, <cite>s_B.axis[0]</cite> refers to axis <cite>x</cite>. Similarly, <cite>s_B.axis[1]</cite> refers
to axis <cite>y</cite>. We can take a look at the generated IR.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">hcl</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>module {
  func.func @top(%arg0: memref&lt;10x100xi32&gt;) -&gt; memref&lt;10x100xi32&gt; attributes {itypes = &quot;s&quot;, otypes = &quot;s&quot;} {
    %0 = memref.alloc() {name = &quot;B&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 100 {
      affine.for %arg2 = 0 to 10 {
        %2 = affine.load %arg0[%arg2, %arg1] {from = &quot;A&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %3 = arith.extsi %2 : i32 to i33
        %4 = arith.extsi %c1_i32 : i32 to i33
        %5 = arith.addi %3, %4 : i33
        %6 = arith.trunci %5 : i33 to i32
        affine.store %6, %0[%arg2, %arg1] {to = &quot;B&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;x&quot;}
    } {loop_name = &quot;y&quot;, op_name = &quot;B&quot;}
    %1 = memref.alloc() {name = &quot;C&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 10 {
      affine.for %arg2 = 0 to 100 {
        %2 = affine.load %0[%arg1, %arg2] {from = &quot;B&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %3 = arith.extsi %2 : i32 to i33
        %4 = arith.extsi %c1_i32 : i32 to i33
        %5 = arith.addi %3, %4 : i33
        %6 = arith.trunci %5 : i33 to i32
        affine.store %6, %1[%arg1, %arg2] {to = &quot;C&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y_0&quot;}
    } {loop_name = &quot;x_0&quot;, op_name = &quot;C&quot;}
    return %1 : memref&lt;10x100xi32&gt;
  }
}
</pre></div>
</div>
<p>We can see that axis <cite>x</cite> and axis <cite>y</cite> are indeed reordered.</p>
</section>
<section id="split">
<h3><code class="docutils literal notranslate"><span class="pre">split</span></code><a class="headerlink" href="#split" title="Permalink to this headline"><span>¶</span></a></h3>
<p>This primitive allows users a to split an axis with a given factor. Namely,
a loop will be split into two sub-loops. For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">([</span><span class="n">A</span><span class="p">],</span> <span class="n">two_stage</span><span class="p">)</span>
<span class="n">s_B</span> <span class="o">=</span> <span class="n">two_stage</span><span class="o">.</span><span class="n">B</span>
<span class="n">x_out</span><span class="p">,</span> <span class="n">x_in</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">s_B</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s_B</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we recreate a new schedule so that we will not confuse it with the
previous schedule. We can see that, with the <code class="docutils literal notranslate"><span class="pre">hcl.split</span></code> primitive, we get
two new axes <cite>x_out</cite> and <cite>x_in</cite>. To make it clear, let’s take a look at the
generated IR.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">hcl</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>#map = affine_map&lt;(d0, d1) -&gt; (d0 + d1 * 5)&gt;
module {
  func.func @top(%arg0: memref&lt;10x100xi32&gt;) -&gt; memref&lt;10x100xi32&gt; attributes {itypes = &quot;s&quot;, otypes = &quot;s&quot;} {
    %0 = memref.alloc() {name = &quot;B&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 2 {
      affine.for %arg2 = 0 to 5 {
        affine.for %arg3 = 0 to 100 {
          %3 = affine.apply #map(%arg2, %arg1)
          %4 = affine.load %arg0[%3, %arg3] {from = &quot;A&quot;} : memref&lt;10x100xi32&gt;
          %c1_i32 = arith.constant 1 : i32
          %5 = arith.extsi %4 : i32 to i33
          %6 = arith.extsi %c1_i32 : i32 to i33
          %7 = arith.addi %5, %6 : i33
          %8 = arith.trunci %7 : i33 to i32
          affine.store %8, %0[%3, %arg3] {to = &quot;B&quot;} : memref&lt;10x100xi32&gt;
        } {loop_name = &quot;y&quot;}
      } {loop_name = &quot;x.inner&quot;}
    } {loop_name = &quot;x.outer&quot;, op_name = &quot;B&quot;}
    %1 = memref.alloc() {name = &quot;C&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 10 {
      affine.for %arg2 = 0 to 100 {
        %3 = affine.load %0[%arg1, %arg2] {from = &quot;B&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %4 = arith.extsi %3 : i32 to i33
        %5 = arith.extsi %c1_i32 : i32 to i33
        %6 = arith.addi %4, %5 : i33
        %7 = arith.trunci %6 : i33 to i32
        affine.store %7, %1[%arg1, %arg2] {to = &quot;C&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y_0&quot;}
    } {loop_name = &quot;x_0&quot;, op_name = &quot;C&quot;}
    %2 = hcl.create_op_handle &quot;B&quot;
    return %1 : memref&lt;10x100xi32&gt;
  }
}
</pre></div>
</div>
<p>The returned variable <cite>x_out</cite> corresponds to the axis <cite>x.outer</cite> in the IR.
Since we split the axis with a factor 5, now the outer loop only iterates
two times with the inner loop iterating from 0 to 5. We can further combine
the <cite>reorder</cite> primitive we just introduced.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">([</span><span class="n">A</span><span class="p">],</span> <span class="n">two_stage</span><span class="p">)</span>
<span class="n">s</span><span class="p">[</span><span class="n">s_B</span><span class="p">]</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">s_B</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_out</span><span class="p">,</span> <span class="n">x_in</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">hcl</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>module {
  func.func @top(%arg0: memref&lt;10x100xi32&gt;) -&gt; memref&lt;10x100xi32&gt; attributes {itypes = &quot;s&quot;, otypes = &quot;s&quot;} {
    %0 = memref.alloc() {name = &quot;B&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 10 {
      affine.for %arg2 = 0 to 100 {
        %2 = affine.load %arg0[%arg1, %arg2] {from = &quot;A&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %3 = arith.extsi %2 : i32 to i33
        %4 = arith.extsi %c1_i32 : i32 to i33
        %5 = arith.addi %3, %4 : i33
        %6 = arith.trunci %5 : i33 to i32
        affine.store %6, %0[%arg1, %arg2] {to = &quot;B&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y&quot;}
    } {loop_name = &quot;x&quot;, op_name = &quot;B&quot;}
    %1 = memref.alloc() {name = &quot;C&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 10 {
      affine.for %arg2 = 0 to 100 {
        %2 = affine.load %0[%arg1, %arg2] {from = &quot;B&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %3 = arith.extsi %2 : i32 to i33
        %4 = arith.extsi %c1_i32 : i32 to i33
        %5 = arith.addi %3, %4 : i33
        %6 = arith.trunci %5 : i33 to i32
        affine.store %6, %1[%arg1, %arg2] {to = &quot;C&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y_0&quot;}
    } {loop_name = &quot;x_0&quot;, op_name = &quot;C&quot;}
    return %1 : memref&lt;10x100xi32&gt;
  }
}
</pre></div>
</div>
<p>In the generated IR, we can see that the three axes are reordered according
to what we specified.</p>
</section>
<section id="fuse">
<h3><code class="docutils literal notranslate"><span class="pre">fuse</span></code><a class="headerlink" href="#fuse" title="Permalink to this headline"><span>¶</span></a></h3>
<p>This primitives is the reversed version of <code class="docutils literal notranslate"><span class="pre">hcl.split</span></code>. Namely, we can
fuse <strong>two consecutive</strong> sub-loops into a single loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">([</span><span class="n">A</span><span class="p">],</span> <span class="n">two_stage</span><span class="p">)</span>
<span class="n">s_B</span> <span class="o">=</span> <span class="n">two_stage</span><span class="o">.</span><span class="n">B</span>
<span class="n">x_y</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">s_B</span><span class="p">]</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">s_B</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s_B</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">hcl</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>#map0 = affine_map&lt;(d0) -&gt; (d0 mod 100)&gt;
#map1 = affine_map&lt;(d0) -&gt; (d0 floordiv 100)&gt;
module {
  func.func @top(%arg0: memref&lt;10x100xi32&gt;) -&gt; memref&lt;10x100xi32&gt; attributes {itypes = &quot;s&quot;, otypes = &quot;s&quot;} {
    %0 = memref.alloc() {name = &quot;B&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 1000 {
      %4 = affine.apply #map0(%arg1)
      %5 = affine.apply #map1(%arg1)
      %6 = affine.load %arg0[%5, %4] {from = &quot;A&quot;} : memref&lt;10x100xi32&gt;
      %c1_i32 = arith.constant 1 : i32
      %7 = arith.extsi %6 : i32 to i33
      %8 = arith.extsi %c1_i32 : i32 to i33
      %9 = arith.addi %7, %8 : i33
      %10 = arith.trunci %9 : i33 to i32
      affine.store %10, %0[%5, %4] {to = &quot;B&quot;} : memref&lt;10x100xi32&gt;
    } {loop_name = &quot;x_y_fused&quot;, op_name = &quot;B&quot;}
    %1 = memref.alloc() {name = &quot;C&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 10 {
      affine.for %arg2 = 0 to 100 {
        %4 = affine.load %0[%arg1, %arg2] {from = &quot;B&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %5 = arith.extsi %4 : i32 to i33
        %6 = arith.extsi %c1_i32 : i32 to i33
        %7 = arith.addi %5, %6 : i33
        %8 = arith.trunci %7 : i33 to i32
        affine.store %8, %1[%arg1, %arg2] {to = &quot;C&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y_0&quot;}
    } {loop_name = &quot;x_0&quot;, op_name = &quot;C&quot;}
    %2 = hcl.create_op_handle &quot;B&quot;
    %3 = hcl.create_loop_handle %2, &quot;x&quot;
    return %1 : memref&lt;10x100xi32&gt;
  }
}
</pre></div>
</div>
<p>Similar to the previous example, we recreate a new schedule. Here we fuse
the two axes <cite>x</cite> and <cite>y</cite> into a single axis <cite>x_y</cite>, which corresponds to
<cite>x.y.fused</cite> in the generated IR. Now the loop iterates from 0 to 1000, as
expected.</p>
</section>
<section id="compute-at">
<h3><code class="docutils literal notranslate"><span class="pre">compute_at</span></code><a class="headerlink" href="#compute-at" title="Permalink to this headline"><span>¶</span></a></h3>
<p>Previously, we focus on the loop transformation within one stage. However,
we can also perform loop transformations across multi-stages. This primitive
allows users to merge the loops from two stages. The idea behind it is to
compute a stage within another stage so that we can reuse some partial
results.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">([</span><span class="n">A</span><span class="p">],</span> <span class="n">two_stage</span><span class="p">)</span>
<span class="n">s_B</span> <span class="o">=</span> <span class="n">two_stage</span><span class="o">.</span><span class="n">B</span>
<span class="n">s_C</span> <span class="o">=</span> <span class="n">two_stage</span><span class="o">.</span><span class="n">C</span>
<span class="n">s</span><span class="p">[</span><span class="n">s_B</span><span class="p">]</span><span class="o">.</span><span class="n">compute_at</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">s_C</span><span class="p">],</span> <span class="n">s_C</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>In this example, we specify stage B to be computed within stage C at the
first axis <cite>x</cite>. Originally, we first completely compute stage B and then
stage C. However, in this scenario, after we finish the computation of
stage B axis <cite>y</cite>, we do not continue on computing the next <cite>x</cite>. Instead,
we go on to compute stage C axis <cite>y</cite>. It would be easier to understand with
the generated IR.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">hcl</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>module {
  func.func @top(%arg0: memref&lt;10x100xi32&gt;) -&gt; memref&lt;10x100xi32&gt; attributes {itypes = &quot;s&quot;, otypes = &quot;s&quot;} {
    %0 = memref.alloc() {name = &quot;B&quot;} : memref&lt;10x100xi32&gt;
    %1 = memref.alloc() {name = &quot;C&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 10 {
      affine.for %arg2 = 0 to 100 {
        %2 = affine.load %arg0[%arg1, %arg2] {from = &quot;A&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %3 = arith.extsi %2 : i32 to i33
        %4 = arith.extsi %c1_i32 : i32 to i33
        %5 = arith.addi %3, %4 : i33
        %6 = arith.trunci %5 : i33 to i32
        affine.store %6, %0[%arg1, %arg2] {to = &quot;B&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y&quot;}
      affine.for %arg2 = 0 to 100 {
        %2 = affine.load %0[%arg1, %arg2] {from = &quot;B&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %3 = arith.extsi %2 : i32 to i33
        %4 = arith.extsi %c1_i32 : i32 to i33
        %5 = arith.addi %3, %4 : i33
        %6 = arith.trunci %5 : i33 to i32
        affine.store %6, %1[%arg1, %arg2] {to = &quot;C&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;y_0&quot;}
    } {loop_name = &quot;x_0&quot;, op_name = &quot;C&quot;}
    return %1 : memref&lt;10x100xi32&gt;
  }
}
</pre></div>
</div>
<p>We can observe from the IR that now both stages share the same outer loop
<cite>x</cite>. Moreover, we only need to allocate the memory for partial results.</p>
</section>
</section>
<section id="parallelism">
<h2>Parallelism<a class="headerlink" href="#parallelism" title="Permalink to this headline"><span>¶</span></a></h2>
<p>In addition to loop transformations, we can also explore the parallelism
within an applications. In this category, normally we just annotate the
loop and the backend code generator will handle the rest. Thus, we do not
explain each parallelism primitive one by one. The primitives we support
include <code class="docutils literal notranslate"><span class="pre">unroll</span></code>, <code class="docutils literal notranslate"><span class="pre">parallel</span></code>, and <code class="docutils literal notranslate"><span class="pre">pipeline</span></code>.</p>
</section>
<section id="combine-all-together">
<h2>Combine All Together<a class="headerlink" href="#combine-all-together" title="Permalink to this headline"><span>¶</span></a></h2>
<p>Finally, we can combine different compute customization primitives together.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">([</span><span class="n">A</span><span class="p">],</span> <span class="n">two_stage</span><span class="p">)</span>
<span class="n">s_B</span> <span class="o">=</span> <span class="n">two_stage</span><span class="o">.</span><span class="n">B</span>
<span class="n">s_C</span> <span class="o">=</span> <span class="n">two_stage</span><span class="o">.</span><span class="n">C</span>

<span class="n">s</span><span class="p">[</span><span class="n">s_B</span><span class="p">]</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">s_B</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s_B</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">s</span><span class="p">[</span><span class="n">s_C</span><span class="p">]</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">s_C</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s_C</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">s</span><span class="p">[</span><span class="n">s_B</span><span class="p">]</span><span class="o">.</span><span class="n">compute_at</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">s_C</span><span class="p">],</span> <span class="n">s_C</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">s</span><span class="p">[</span><span class="n">s_C</span><span class="p">]</span><span class="o">.</span><span class="n">parallel</span><span class="p">(</span><span class="n">s_C</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">s</span><span class="p">[</span><span class="n">s_C</span><span class="p">]</span><span class="o">.</span><span class="n">pipeline</span><span class="p">(</span><span class="n">s_C</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">hcl</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>module {
  func.func @top(%arg0: memref&lt;10x100xi32&gt;) -&gt; memref&lt;10x100xi32&gt; attributes {itypes = &quot;s&quot;, otypes = &quot;s&quot;} {
    %0 = memref.alloc() {name = &quot;C&quot;} : memref&lt;10x100xi32&gt;
    affine.for %arg1 = 0 to 100 {
      affine.for %arg2 = 0 to 10 {
        %1 = affine.load %arg0[%arg2, %arg1] {from = &quot;A&quot;} : memref&lt;10x100xi32&gt;
        %c1_i32 = arith.constant 1 : i32
        %2 = arith.extsi %1 : i32 to i33
        %3 = arith.extsi %c1_i32 : i32 to i33
        %4 = arith.addi %2, %3 : i33
        %5 = arith.trunci %4 : i33 to i32
        %6 = arith.extsi %5 : i32 to i33
        %7 = arith.addi %6, %3 : i33
        %8 = arith.trunci %7 : i33 to i32
        affine.store %8, %0[%arg2, %arg1] {to = &quot;C&quot;} : memref&lt;10x100xi32&gt;
      } {loop_name = &quot;x_0&quot;, pipeline_ii = 1 : i32}
    } {loop_name = &quot;y_0&quot;, op_name = &quot;C&quot;, parallel = 1 : i32}
    return %0 : memref&lt;10x100xi32&gt;
  }
}
</pre></div>
</div>
</section>
<section id="apply-to-imperative-dsl">
<h2>Apply to Imperative DSL<a class="headerlink" href="#apply-to-imperative-dsl" title="Permalink to this headline"><span>¶</span></a></h2>
<p>HeteroCL also lets users to apply these primitives to imperative DSLs. In
other words, all the loops written with <code class="docutils literal notranslate"><span class="pre">hcl.for_</span></code> can be applied. To do
that, we also need to name those axes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hcl</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="mi">10</span><span class="p">,))</span>


<span class="k">def</span> <span class="nf">custom_imperative</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">hcl</span><span class="o">.</span><span class="n">for_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">10</span>


<span class="n">s</span> <span class="o">=</span> <span class="n">hcl</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">([</span><span class="n">A</span><span class="p">],</span> <span class="n">custom_imperative</span><span class="p">)</span>
<span class="n">s_S</span> <span class="o">=</span> <span class="n">custom_imperative</span><span class="o">.</span><span class="n">S</span>
<span class="n">i_out</span><span class="p">,</span> <span class="n">i_in</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">s_S</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s_S</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">hcl</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>#map = affine_map&lt;(d0, d1) -&gt; (d0 + d1 * 2)&gt;
module {
  func.func @top(%arg0: memref&lt;10xi32&gt;) attributes {itypes = &quot;s&quot;, otypes = &quot;&quot;} {
    affine.for %arg1 = 0 to 5 {
      affine.for %arg2 = 0 to 2 {
        %1 = affine.apply #map(%arg2, %arg1)
        %c10_i32 = arith.constant 10 : i32
        %2 = arith.index_cast %1 : index to i34
        %3 = arith.extsi %c10_i32 : i32 to i34
        %4 = arith.subi %2, %3 : i34
        %5 = arith.trunci %4 : i34 to i32
        affine.store %5, %arg0[%1] {to = &quot;tensor_0&quot;} : memref&lt;10xi32&gt;
      } {loop_name = &quot;i.inner&quot;}
    } {loop_name = &quot;i.outer&quot;, op_name = &quot;S&quot;}
    %0 = hcl.create_op_handle &quot;S&quot;
    return
  }
}
</pre></div>
</div>
<p>We can also access the imperative axes with their showing up order.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">s_S</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="n">s_S</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.099 seconds)</p>
<div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-gallery-tutorial-04-compute-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/d920dda4f62249593747253ec50d3171/tutorial_04_compute.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_04_compute.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/cde269890b52fc0b2d1b779b005c3e15/tutorial_04_compute.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_04_compute.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    
        <div id="show_right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon"><</span><span>Page contents<span></a></p>
        </div>

        <div id="right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon">></span><span>Page contents:<span></a></p>
            <div class="page_toc">
                <ul>
<li><a class="reference internal" href="#">Compute Customization</a><ul>
<li><a class="reference internal" href="#hardware-customization">Hardware Customization</a></li>
<li><a class="reference internal" href="#loop-transformation">Loop Transformation</a><ul>
<li><a class="reference internal" href="#reorder"><code class="docutils literal notranslate"><span class="pre">reorder</span></code></a></li>
<li><a class="reference internal" href="#split"><code class="docutils literal notranslate"><span class="pre">split</span></code></a></li>
<li><a class="reference internal" href="#fuse"><code class="docutils literal notranslate"><span class="pre">fuse</span></code></a></li>
<li><a class="reference internal" href="#compute-at"><code class="docutils literal notranslate"><span class="pre">compute_at</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#parallelism">Parallelism</a></li>
<li><a class="reference internal" href="#combine-all-together">Combine All Together</a></li>
<li><a class="reference internal" href="#apply-to-imperative-dsl">Apply to Imperative DSL</a></li>
</ul>
</li>
</ul>

            </div>
        </div>
    

      <div class="clearer"></div>
    </div>
    <div class="button_nav_wrapper">
        <div class="button_nav">
            <div class="left">
                
                <a href="tutorial_03_api.html">
                    <span class="icon"><</span><span>HeteroCL Compute APIs</span></a>
                
            </div>

            <div class="right">
                
                    <a href="tutorial_05_dtype.html"><span>Data Type Customization</span><span class="icon">></span></a>
                
            </div>
        </div>
    </div>


    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, HeteroCL Authors.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

<p id="theme_credit">Styled using the <a href="https://github.com/piccolo-orm/piccolo_theme">Piccolo Theme</a></p>
  </body>
</html>