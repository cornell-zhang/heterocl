import heterocl as hcl
import numpy as np
from itertools import permutations
import os
import sys

def test_autosa_schedule():
    m=3
    n=3
    k=3
    dtype=hcl.Int()

    matrix_1 = hcl.placeholder((m, k), dtype=dtype, name="W")
    matrix_2 = hcl.placeholder((k, n), dtype=dtype, name="X")

    def kernel(matrix_1, matrix_2):
        # imperative (without transposed matrix B)
        Y = hcl.compute((m, n), lambda *args: 0, name="Y0")
        with hcl.Stage("Y"):
            with hcl.for_(0, m) as i:
                with hcl.for_(0, n) as j:
                    Y[i][j] = 0
                    with hcl.for_(0, k) as r:
                        Y[i][j] += matrix_1[i][r] * matrix_2[r][j]

        # r = hcl.reduce_axis(0, k, 'k')
        # return hcl.compute((m, n), lambda x, y: 
        #     hcl.sum(matrix_1[x, r] * matrix_2[r, y], axis=r, dtype=dtype),
        #         dtype=dtype, name="Y")

    p = hcl.Platform.aws_f1
    p.config(compile="vitis", mode="debug")
    s = hcl.create_schedule([matrix_1, matrix_2], kernel)

    # The unrolled PEs scheduling is handled by AutoSA 
    PEs = s.parallel(kernel.Y, axis=[0,1])
    assert PEs.size == (3,3)
    print(PEs[0,0].op.inputs)
    print(PEs[:,0])

    # Schedule with .to using high order function
    # Example of 3x3 inputs braodcasting and inter-PE streaming
    # 1. Broadcasting matrix X from left
    # 2. Broadcasting matrix W from top
    s.to(matrix_1, p.xcel).to(PEs[0,:], mode=hcl.IO.Stream)
    s.to(matrix_2, p.xcel).to(PEs[:,0], mode=hcl.IO.DMA)

    # 3. Create inter-PE streaming channels
    higher_order_func = False
    if not higher_order_func:
        [ s.to(PEs[k,0].X, PEs[k,1]).to(PEs[k,2]) for k in range(m) ]
        [ s.to(PEs[0,k].W, PEs[1,k]).to(PEs[2,k]) for k in range(n) ]
        [ s.to(PEs[i,j].Y0, kernel.Y.Y0).to(p.host) for i in range(m) for j in range(n) ]
    # Or in other ways
    else:
        map(lambda k: s.to(PEs[k,0].X, PEs[k,1]).to(PEs[k,2]), range(m))
        map(lambda k: s.to(PEs[0,k].W, PEs[1,k]).to(PEs[2,k]), range(n))
        map(lambda i,j: s.to(PEs[i,j], kernel.Y.Y0).to(p.host), range(m), range(n))

    # Check the annotation embedded in th IR
    print(hcl.lower(s))


# Parse the generated by AutoSA
def test_autosa_gemm():
    m=64
    n=64
    k=64
    dtype=hcl.Int()

    matrix_1 = hcl.placeholder((m, k), dtype=dtype, name="W")
    matrix_2 = hcl.placeholder((k, n), dtype=dtype, name="X")

    def kernel(matrix_1, matrix_2):
        # imperative (without transposed matrix B)
        Y = hcl.compute((m, n), lambda *args: 0, name="Y0")
        with hcl.Stage("Y"):
            with hcl.for_(0, m) as i:
                with hcl.for_(0, n) as j:
                    Y[i][j] = 0
                    with hcl.for_(0, k) as r:
                        Y[i][j] += matrix_1[i][r] * matrix_2[r][j]

        # r = hcl.reduce_axis(0, k, 'k')
        # return hcl.compute((m, n), lambda x, y: 
        #     hcl.sum(matrix_1[x, r] * matrix_2[r, y], axis=r, dtype=dtype),
        #         dtype=dtype, name="Y")

    target = hcl.Platform.aws_f1
    target.config(compile="vitis", mode="debug")
    s = hcl.create_schedule([matrix_1, matrix_2], kernel)

    # Do extern ip
    s[kernel.Y].systolic()
    print(hcl.build(s, target))


# Ensure the basic mode is activated
def test_basic_streaming():
    hcl.init()
    A = hcl.placeholder((10, 32), "A")
    B = hcl.placeholder((10, 32), "B")
    def kernel(A, B):
        C = hcl.compute(A.shape, lambda *args : B[args] + A[args], "C")
        return C
   
    target = hcl.Platform.aws_f1
    target.config(compile="vitis", mode="debug")
    s = hcl.create_schedule([A, B], kernel)

    # HCL will automatically apply .to with DMA mode 
    # if .to is not applied by users explicitly
    stream = True
    if stream:
        s.to([A, B], target.xcel, mode=hcl.IO.Stream)
        s.to(kernel.C, target.host, mode=hcl.IO.Stream)

    code = str(hcl.build(s, target))
    print(code)

def test_stencil_stream():
    shape = (480, 640)
    def jacobi(input_image):
        tensor = hcl.compute(shape, lambda y, x: 
            input_image[y,x,0]*0.3 + input_image[y,x,1]*0.59+input_image[y,x,2]*0.11 , "gray")
        def jacobi_kernel(y, x):
            return (tensor[y+1, x-1] +
                    tensor[y  , x  ] +
                    tensor[y+1, x  ] +
                    tensor[y+1, x+1] +
                    tensor[y+2, x  ]) / 5

        return hcl.compute(shape, jacobi_kernel, name="output")

    dtype = hcl.Float()
    input_image = hcl.placeholder((*shape, 3), name="input", dtype=dtype)
    s = hcl.create_schedule([input_image], jacobi)
    s[jacobi.output].stencil(unroll_factor=8)

    # Stream from grayscale to stencil module
    s.to(jacobi.gray, jacobi.output, depth=10)

    print(hcl.build(s, target='soda'))
    print(hcl.build(s, target='soda_xhls'))
    print(hcl.build(s, target='vhls'))


def test_static_variable():
    hcl.init()
    W = hcl.placeholder((3,), "W")
    X = hcl.placeholder((32,), "X")

    def kernel(W, X):
        k = hcl.reduce_axis(0, 3, "k")
        return hcl.compute((30,), lambda x: hcl.sum(X[x+k]*W[k], axis=k), "Y")
    
    target = hcl.Platform.aws_f1
    sch = hcl.create_schedule([W, X], kernel)

    # The loop reorder seems not to work on imperfect loops
    # sch[Y].reorder(Y.axis[0], Y.axis[1])

    # The analysis is offloaded to AutoSA and we just inject 
    # information into the IR
    pes = sch.parallel(kernel.Y, axis=kernel.Y.axis[1])
    pe1, pe2, pe3 = pes

    # Data movement and broadcasting
    sch.to(W, target.xcel)
    sch.to(X, target.xcel).to([pe1, pe2, pe3])
    sch.to(kernel.Y, target.host)

    # if there is no data movement information specified
    # then each undefined variable creates a port
    code = str(hcl.lower(sch))
    assert "Y_pe_0" in code, code
    assert "Y_pe_1" in code, code
    assert "Y_pe_2" in code, code

def test_weight_stationary_sa():
    hcl.init()
    W = hcl.placeholder((3,), "W")
    X = hcl.placeholder((32,), "X")

    def kernel(W, X):
        k = hcl.reduce_axis(0, 3, "k")
        return hcl.compute((30,), lambda x: 
            hcl.sum(X[x+k]*W[k], axis=k, name="sum"), "Y")
    
    config = {
        "host" : hcl.dev.cpu("intel", "e5"),
        "xcel" : [
             hcl.dev.fpga("xilinx", "xcvu19p")
        ]
    }
    p = hcl.Platform.custom(config)
    p.config(compile="vitis", mode="debug", backend="vhls")
    s = hcl.create_schedule([W, X], kernel)

    pes = s.parallel(kernel.Y, axis=kernel.Y.axis[1])
    pe1, pe2, pe3 = pes

    # Data movement and broadcasting
    s.to(W, p.xcel)
    s.to(X, p.xcel).to([pe1, pe2, pe3])
    s.to(kernel.Y, p.host)

    # Move data betwen PEs
    # tensor "sum" is consumed by all the pe stages
    # we need differentiate from the regular tensor multi-casting
    s.to(pe1.sum, pe2).to(pe3).to(kernel.Y)
    print(hcl.lower(s))
    code = str(hcl.build(s, p))
    print(code)

# Simple read and write kernel
def test_inter_module_stream():
    hcl.init()
    A = hcl.placeholder((10, 32), "A")

    def kernel(A):
        B = hcl.compute((10, 32), lambda *args: 0, "B")
        C = hcl.compute((10, 32), lambda *args: 0, "C")
        
        @hcl.def_([(10, 32), (10, 32)])
        def add(A, B):
            hcl.update(B, lambda *args: A[args] + 1)

        @hcl.def_([(10, 32), (10, 32)])
        def mul(B, C):
            hcl.update(C, lambda *args: B[args] * 2)
            
        add(A, B)
        mul(B, C)

    target = hcl.Platform.aws_f1
    s = hcl.create_schedule([A], kernel)
    
    # Stream one kernel's output to another's input
    s.to(kernel.add.B, kernel.mul.B)
    print(hcl.lower(s))

# GEMM example unrolling on two dimension
def test_two_loops():
    m=2
    n=2
    k=2
    dtype=hcl.Int()

    matrix_1 = hcl.placeholder((m, k), dtype=dtype, name="W")
    matrix_2 = hcl.placeholder((k, n), dtype=dtype, name="X")

    def kernel(matrix_1, matrix_2):
        r = hcl.reduce_axis(0, k, 'k')
        return hcl.compute((m, n), lambda x, y: 
            hcl.sum(matrix_1[x, r] * matrix_2[r, y], axis=r, dtype=dtype),
                dtype=dtype, name="Y")

    s = hcl.create_schedule([matrix_1, matrix_2], kernel)
    # Example body of s[kernel.Y].op:
    # for "stage_name"="Y" (x, 0, 2) {
    #   // attr [iter_var(x, Range(min=0, extent=2))] loop_scope = x
    #   for "stage_name"="Y" (y, 0, 2) {
    #     // attr [iter_var(y, Range(min=0, extent=2))] loop_scope = y
    #     // attr [buffer(sum, 0x55e801b07bd0)] attach_scope = "Y"
    #     for "stage_name"="Y" (k, 0, 2) {
    #       // attr [iter_var(k, Range(min=0, extent=2))] loop_scope = k
    #       sum[0] = W[(k + (x*2))])*X[(y + (k*2))] + sum[0]
    #     }
    #     Y[(y + (x*2))] = int32(sum[0])
    #   }
    # }

    # Unroll the two innermost loops to PE array
    # Has to be in-order (from outermost to innermost)
    axes = [ kernel.Y.axis[1], kernel.Y.axis[2] ]
    pes = s.parallel(kernel.Y, axis=axes)

    # The stage layout should be 
    # 1. Multiple substages attaching to the parent stage
    # 2. The parent stage includes the original body and attaching anchors
    print(pes[0][0].op)
    print(pes[0][1].op)
    print(pes[1][0].op)
    print(pes[1][1].op)

    # Each PE body is marked as virtual stage
    # we will keep the original body for actual code generation
    # The layout information is embedded using .to()
    print(hcl.lower(s))

def test_unroll_outer_loops():
    m=2
    n=2
    k=2
    dtype=hcl.Int()

    matrix_1 = hcl.placeholder((m, k), dtype=dtype, name="W")
    matrix_2 = hcl.placeholder((k, n), dtype=dtype, name="X")

    def kernel(matrix_1, matrix_2):
        r = hcl.reduce_axis(0, k, 'k')
        return hcl.compute((m, n), lambda x, y: 
            hcl.sum(matrix_1[x, r] * matrix_2[r, y], axis=r, dtype=dtype),
                dtype=dtype, name="Y")

    s = hcl.create_schedule([matrix_1, matrix_2], kernel)

    # unroll the spatial dimension 
    # keep the temporal dimension inside the PE
    axes = [ kernel.Y.axis[1], kernel.Y.axis[2] ]
    pes = s.parallel(kernel.Y, axis=kernel.Y.axis[1])
    pe1, pe2 = pes
    code = str(hcl.lower(s))

if __name__ == '__main__':
    test_autosa_schedule()
    test_static_variable()
    test_two_loops()
    test_autosa_gemm()
    test_basic_streaming()
    test_unroll_outer_loops() 
    test_inter_module_stream()
    test_stencil_stream()
    test_weight_stationary_sa()
